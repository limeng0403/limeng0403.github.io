<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>35 道咱们必须要清楚的 React 面试题 | 大猛的私人空间</title>
<meta name="description" content="他人即地狱" />
<link rel="shortcut icon" href="http://lionney.coding.me//favicon.ico?v=1573808930077">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="http://lionney.coding.me//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="http://lionney.coding.me/">
  <img class="avatar" src="http://lionney.coding.me//images/avatar.png?v=1573808930077" alt="">
  </a>
  <h1 class="site-title">
    大猛的私人空间
  </h1>
  <p class="site-description">
    他人即地狱
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              35 道咱们必须要清楚的 React 面试题
            </h2>
            <div class="post-info">
              <span>
                Nov 08 312th
              </span>
              <span>
                21 min read
              </span>
              
                <a href="http://lionney.coding.me//tag/ddY3-0XPE" class="post-tag">
                  # reactjs
                </a>
              
                <a href="http://lionney.coding.me//tag/7Cy1PR8tr" class="post-tag">
                  # js
                </a>
              
                <a href="http://lionney.coding.me//tag/Vc5UAnXnk" class="post-tag">
                  # 文摘
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h3 id="问题1什么是虚拟dom">问题1：什么是虚拟DOM？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐</p>
</blockquote>
<p>虚拟 DOM (VDOM)是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。</p>
<!-- more -->
<h3 id="问题2类组件和函数组件之间的区别是啥">问题2：类组件和函数组件之间的区别是啥？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐</p>
</blockquote>
<ul>
<li>类组件可以使用其他特性，如状态 state 和生命周期钩子。</li>
<li>当组件只是接收 props 渲染到页面时，就是无状态组件，就属于函数组件，也被称为哑组件或展示组件。</li>
</ul>
<p>函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。</p>
<table>
<thead>
<tr>
<th>区别</th>
<th style="text-align:left">函数组件</th>
<th style="text-align:center">类组件</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否有 this</td>
<td style="text-align:left">没有</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td>是否有生命周期</td>
<td style="text-align:left">没有</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td>是否有状态 state</td>
<td style="text-align:left">没有</td>
<td style="text-align:center">有</td>
</tr>
</tbody>
</table>
<h3 id="问题-3react-中-refs-干嘛用的">问题 3：React 中 refs 干嘛用的？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐</p>
</blockquote>
<p>Refs 提供了一种访问在render方法中创建的 DOM 节点或者 React 元素的方法。在典型的数据流中，props 是父子组件交互的唯一方式，想要修改子组件，需要使用新的pros重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用 Refs。<br>
咱们可以在组件添加一个 ref 属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层 DOM 元素或组件的挂载实例。</p>
<pre><code class="language-javascript">class UnControlledForm extends Component {
  handleSubmit = () =&gt; {
    console.log(&quot;Input Value: &quot;, this.input.value)
  }
  render () {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;input
          type='text'
          ref={(input) =&gt; this.input = input} /&gt;
        &lt;button type='submit'&gt;Submit&lt;/button&gt;
      &lt;/form&gt;
    )
  }
}
</code></pre>
<p>请注意，input 元素有一个ref属性，它的值是一个函数。该函数接收输入的实际 DOM 元素，然后将其放在实例上，这样就可以在 handleSubmit 函数内部访问它。<br>
经常被误解的只有在类组件中才能使用 refs，但是refs也可以通过利用 JS 中的闭包与函数组件一起使用。</p>
<pre><code class="language-javascript">function CustomForm ({handleSubmit}) {
  let inputElement
  return (
    &lt;form onSubmit={() =&gt; handleSubmit(inputElement.value)}&gt;
      &lt;input
        type='text'
        ref={(input) =&gt; inputElement = input} /&gt;
      &lt;button type='submit'&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  )
}
</code></pre>
<h3 id="问题-4在-react-中如何处理事件">问题 4：在 React 中如何处理事件</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐</p>
</blockquote>
<p>为了解决跨浏览器的兼容性问题，SyntheticEvent 实例将被传递给你的事件处理函数，SyntheticEvent是 React 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。<br>
比较有趣的是，React 实际上并不将事件附加到子节点本身。React 使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着 React 在更新 DOM 时不需要跟踪事件监听器。</p>
<h3 id="问题-5state-和-props-区别是啥">问题 5：state 和 props 区别是啥？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐</p>
</blockquote>
<p>props和state是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即</p>
<ul>
<li>state 是组件自己管理数据，控制自己的状态，可变；</li>
<li>props 是外部传入的数据参数，不可变；</li>
<li>没有state的叫做无状态组件，有state的叫做有状态组件；</li>
<li>多用 props，少用 state，也就是多写无状态组件。</li>
</ul>
<h3 id="问题-6如何创建-refs">问题 6：如何创建 refs</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐</p>
</blockquote>
<p>Refs 是使用 React.createRef() 创建的，并通过 ref 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。</p>
<pre><code class="language-javascript">class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return &lt;div ref={this.myRef} /&gt;;
  }
}
</code></pre>
<p>或者这样用：</p>
<pre><code class="language-javascript">class UserForm extends Component {
  handleSubmit = () =&gt; {
    console.log(&quot;Input Value is: &quot;, this.input.value)
  }
  render () {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;input
          type='text'
          ref={(input) =&gt; this.input = input} /&gt; // Access DOM input in handle submit
        &lt;button type='submit'&gt;Submit&lt;/button&gt;
      &lt;/form&gt;
    )
  }
}
</code></pre>
<h3 id="问题-7什么是高阶组件">问题 7：什么是高阶组件？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐</p>
</blockquote>
<p>高阶组件(HOC)是接受一个组件并返回一个新组件的函数。基本上，这是一个模式，是从 React 的组合特性中衍生出来的，称其为纯组件，因为它们可以接受任何动态提供的子组件，但不会修改或复制输入组件中的任何行为。<br>
<code>const EnhancedComponent = higherOrderComponent(WrappedComponent);</code><br>
HOC 可以用于以下许多用例</p>
<ul>
<li>代码重用、逻辑和引导抽象</li>
<li>渲染劫持</li>
<li>state 抽象和操作</li>
<li>props 处理</li>
</ul>
<h3 id="问题-8在构造函数调用-super-并将-props-作为参数传入的作用是啥">问题 8：在构造函数调用 super 并将 props 作为参数传入的作用是啥？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐</p>
</blockquote>
<p>在调用 super() 方法之前，子类构造函数无法使用this引用，ES6 子类也是如此。将 props 参数传递给 super() 调用的主要原因是在子构造函数中能够通过this.props来获取传入的 props。<br>
传递 props</p>
<pre><code class="language-javascript">class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    console.log(this.props);  // { name: 'sudheer',age: 30 }
  }
}
</code></pre>
<p>没传递 props</p>
<pre><code class="language-javascript">class MyComponent extends React.Component {
  constructor(props) {
    super();
    console.log(this.props); // undefined
    // 但是 Props 参数仍然可用
    console.log(props); // Prints { name: 'sudheer',age: 30 }
  }

  render() {
    // 构造函数外部不受影响
    console.log(this.props) // { name: 'sudheer',age: 30 }
  }
}
</code></pre>
<p>上面示例揭示了一点。props 的行为只有在构造函数中是不同的，在构造函数之外也是一样的。</p>
<h3 id="问题-9什么是控制组件">问题 9：什么是控制组件？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<p>在 HTML 中，表单元素如 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>和<code>&lt;select&gt;</code>通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。<br>
而 React 的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数(例如onChange)触发时重新渲染组件，因为状态被更新。以这种方式由 React 控制其值的输入表单元素称为受控组件。</p>
<h3 id="问题-10如何-reactcreateelement">问题 10：如何 React.createElement ？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<p>问题：</p>
<pre><code class="language-javascript">const element = (
  &lt;h1 className=&quot;greeting&quot;&gt;
    Hello, world!
  &lt;/h1&gt;
)
</code></pre>
<p>上述代码如何使用 React.createElement 来实现:</p>
<pre><code class="language-javascript">const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
</code></pre>
<h3 id="问题-11讲讲什么是-jsx">问题 11：讲讲什么是 JSX ？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<p>当 Facebook 第一次发布 React 时，他们还引入了一种新的 JS 方言 JSX，将原始 HTML 模板嵌入到 JS 代码中。JSX 代码本身不能被浏览器读取，必须使用Babel和webpack等工具将其转换为传统的JS。很多开发人员就能无意识使用 JSX，因为它已经与 React 结合在一直了。</p>
<pre><code class="language-javascript">class MyComponent extends React.Component {
  render() {
    let props = this.props;  
    return (
      &lt;div className=&quot;my-component&quot;&gt;
      &lt;a href={props.url}&gt;{props.name}&lt;/a&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<h3 id="问题-12根据下面定义的代码可以找出存在的两个问题吗">问题 12：根据下面定义的代码，可以找出存在的两个问题吗 ？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<p>请看下面的代码：<br>
<img src="http://lionney.coding.me//post-images/1573181405119.jpg" alt=""></p>
<p>答案：</p>
<p>1.在构造函数没有将 props 传递给 super，它应该包括以下行</p>
<pre><code class="language-javascript">constructor(props) {
  super(props);
  // ...
}
</code></pre>
<p>2.事件监听器(通过addEventListener()分配时)的作用域不正确，因为 ES6 不提供自动绑定。因此，开发人员可以在构造函数中重新分配clickHandler来包含正确的绑定:</p>
<pre><code class="language-javascript">constructor(props) {
  super(props);
  this.clickHandler = this.clickHandler.bind(this);
  // ...
}
</code></pre>
<h3 id="问题-13为什么不直接更新-state-呢">问题 13：为什么不直接更新 state 呢 ?</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<p>如果试图直接更新 state ，则不会重新渲染组件。</p>
<pre><code class="language-javascript">// 错误
This.state.message = 'Hello world';
</code></pre>
<p>需要使用setState()方法来更新 state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应：</p>
<pre><code class="language-javascript">// 正确做法
This.setState({message: ‘Hello World’});
</code></pre>
<h3 id="问题-14react-组件生命周期有哪些不同阶段">问题 14：React 组件生命周期有哪些不同阶段？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<p>在组件生命周期中有四个不同的阶段：</p>
<p>1.Initialization：在这个阶段，组件准备设置初始化状态和默认属性。</p>
<p>2.Mounting：react 组件已经准备好挂载到浏览器 DOM 中。这个阶段包括componentWillMount和componentDidMount生命周期方法。</p>
<p>3.Updating：在这个阶段，组件以两种方式更新，发送新的 props 和 state 状态。此阶段包括shouldComponentUpdate、componentWillUpdate和componentDidUpdate生命周期方法。</p>
<p>4.Unmounting：在这个阶段，组件已经不再被需要了，它从浏览器 DOM 中卸载下来。这个阶段包含 componentWillUnmount 生命周期方法。</p>
<p>除以上四个常用生命周期外，还有一个错误处理的阶段：</p>
<p>Error Handling：在这个阶段，不论在渲染的过程中，还是在生命周期方法中或是在任何子组件的构造函数中发生错误，该组件都会被调用。这个阶段包含了 componentDidCatch 生命周期方法。</p>
<figure data-type="image" tabindex="1"><img src="http://lionney.coding.me//post-images/1573181817393.jpg" alt=""></figure>
<h3 id="问题-15react-的生命周期方法有哪些">问题 15：React 的生命周期方法有哪些？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<ul>
<li>
<p>componentWillMount:在渲染之前执行，用于根组件中的 App 级配置。</p>
</li>
<li>
<p>componentDidMount：在第一次渲染之后执行，可以在这里做AJAX请求，DOM 的操作或状态更新以及设置事件监听器。</p>
</li>
<li>
<p>componentWillReceiveProps：在初始化render的时候不会执行，它会在组件接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染</p>
</li>
<li>
<p>shouldComponentUpdate：确定是否更新组件。默认情况下，它返回true。如果确定在 state 或 props 更新后组件不需要在重新渲染，则可以返回false，这是一个提高性能的方法。</p>
</li>
<li>
<p>componentWillUpdate：在shouldComponentUpdate返回 true 确定要更新组件之前件之前执行。</p>
</li>
<li>
<p>componentDidUpdate：它主要用于更新DOM以响应props或state更改。</p>
</li>
<li>
<p>componentWillUnmount：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器。</p>
</li>
</ul>
<h3 id="问题-16这三个点在-react-干嘛用的">问题 16：这三个点(...)在 React 干嘛用的？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<p><code>...</code> 在React（使用JSX）代码中做什么？它叫什么？</p>
<pre><code class="language-html">&lt;Modal {...this.props} title='Modal heading'  animation={false}/&gt;
</code></pre>
<p>这个叫扩展操作符号或者展开操作符，例如，如果this.props包含a：1和b：2，则</p>
<pre><code class="language-html">&lt;Modal {...this.props} title='Modal heading' animation={false}&gt;
</code></pre>
<p>等价于下面内容：</p>
<pre><code class="language-html">&lt;Modal a={this.props.a} b={this.props.b} title='Modal heading' animation={false}&gt;
</code></pre>
<p>扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便，在更新state 咱们就经常这么做：</p>
<pre><code class="language-javascript">this.setState(prevState =&gt; {
    return {foo: {...prevState.foo, a: &quot;updated&quot;}};
});
</code></pre>
<h3 id="问题-17使用-react-hooks-好处是啥">问题 17：使用 React Hooks 好处是啥？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<p>首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。Hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。<br>
Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。</p>
<h3 id="问题-18什么是-react-hooks">问题 18：什么是 React Hooks？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<p>Hooks是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用state和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。</p>
<h3 id="问题-19react-中的-usestate-是什么">问题 19：React 中的 useState() 是什么？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<p>下面说明useState(0)的用途：</p>
<pre><code class="language-javascript">...
const [count, setCounter] = useState(0);
const [moreStuff, setMoreStuff] = useState(...);
...

const setCount = () =&gt; {
    setCounter(count + 1);
    setMoreStuff(...);
    ...
};
</code></pre>
<p>useState 是一个内置的 React Hook。useState(0) 返回一个元组，其中第一个参数count是计数器的当前状态，setCounter 提供更新计数器状态的方法。<br>
咱们可以在任何地方使用setCounter方法更新计数状态-在这种情况下，咱们在setCount函数内部使用它可以做更多的事情，使用 Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。</p>
<h3 id="问题-20react-中的strictmode严格模式是什么">问题 20：React 中的StrictMode(严格模式)是什么？？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<p>React 的StrictMode是一种辅助组件，可以帮助咱们编写更好的 react 组件，可以使用<code>&lt;StrictMode /&gt;</code>包装一组组件，并且可以帮咱们以下检查：</p>
<ul>
<li>
<p>验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告。</p>
</li>
<li>
<p>验证是否使用的已经废弃的方法，如果有，会在控制台给出警告。</p>
</li>
<li>
<p>通过识别潜在的风险预防一些副作用。</p>
</li>
</ul>
<h3 id="问题-21为什么类方法需要绑定到类实例">问题 21：为什么类方法需要绑定到类实例？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<p>在 JS 中，this 值会根据当前上下文变化。在 React 类组件方法中，开发人员通常希望 this 引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的:</p>
<pre><code class="language-javascript">class SubmitButton extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isFormSubmitted: false
    };
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleSubmit() {
    this.setState({
      isFormSubmitted: true
    });
  }

  render() {
    return (
      &lt;button onClick={this.handleSubmit}&gt;Submit&lt;/button&gt;
    )
  }
}
</code></pre>
<h3 id="问题-22什么是-prop-drilling如何避免">问题 22：什么是 prop drilling，如何避免？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<p>在构建 React 应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个 prop 从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做prop drilling。<br>
prop drilling的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。<br>
为了避免prop drilling，一种常用的方法是使用React Context。通过定义提供数据的Provider组件，并允许嵌套的组件通过Consumer组件或useContext Hook 使用上下文数据。</p>
<h3 id="问题-23描述-flux-与-mvc">问题 23：描述 Flux 与 MVC？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<p>传统的 MVC 模式在分离数据(Model)、UI(View和逻辑(Controller)方面工作得很好，但是 MVC 架构经常遇到两个主要问题:</p>
<p><strong>数据流不够清晰</strong>:跨视图发生的级联更新常常会导致混乱的事件网络，难于调试。</p>
<p><strong>缺乏数据完整性</strong>:模型数据可以在任何地方发生突变，从而在整个UI中产生不可预测的结果。</p>
<p>使用 Flux 模式的复杂用户界面不再遭受级联更新，任何给定的React 组件都能够根据 store 提供的数据重建其状态。Flux 模式还通过限制对共享数据的直接访问来加强数据完整性。</p>
<h3 id="问题-24受控组件和非受控组件区别是啥">问题 24：受控组件和非受控组件区别是啥？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐</p>
</blockquote>
<p><strong>受控组件</strong>是 React 控制中的组件，并且是表单数据真实的唯一来源。<br>
非受控组件是由 DOM 处理表单数据的地方，而不是在 React 组件中。</p>
<p>尽管非受控组件通常更易于实现，因为只需使用refs即可从 DOM 中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。<br>
这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式。</p>
<h3 id="问题-25这段代码有什么问题吗">问题 25：这段代码有什么问题吗？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>这段代码有什么问题:</p>
<pre><code class="language-javascript">this.setState((prevState, props) =&gt; {
  return {
    streak: prevState.streak + props.count
  }
})
</code></pre>
<p>答案：</p>
<p>没有什么问题。这种方式很少被使用，咱们可以将一个函数传递给setState，该函数接收上一个 state 的值和当前的props，并返回一个新的状态，如果咱们需要根据以前的状态重新设置状态，推荐使用这种方式。</p>
<h3 id="问题-26什么是-react-context">问题 26：什么是 React Context?</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。</p>
<h3 id="问题-27什么是-react-fiber">问题 27：什么是 React Fiber?</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>Fiber 是 React 16 中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟DOM的增量渲染。React Fiber 的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。<br>
React Fiber 的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染:能够将渲染工作分割成块，并将其分散到多个帧中。</p>
<h3 id="问题-28如何在-reactjs-的-props上应用验证">问题 28：如何在 ReactJS 的 Props上应用验证？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>当应用程序在开发模式下运行时，React 将自动检查咱们在组件上设置的所有 props，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的 props 用 isRequired定义的。</p>
<p>下面是一组预定义的 prop 类型:</p>
<ul>
<li>React.PropTypes.string</li>
<li>React.PropTypes.number</li>
<li>React.PropTypes.func</li>
<li>React.PropTypes.node</li>
<li>React.PropTypes.bool</li>
</ul>
<p>例如，咱们为用户组件定义了如下的propTypes</p>
<pre><code class="language-javascript">import PropTypes from 'prop-types';

class User extends React.Component {
  render() {
    return (
      &lt;h1&gt;Welcome, {this.props.name}&lt;/h1&gt;
      &lt;h2&gt;Age, {this.props.age}
    );
  }
}

User.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number.isRequired
};
</code></pre>
<h3 id="问题-29在-react-中使用构造函数和-getinitialstate-有什么区别">问题 29：在 React 中使用构造函数和 getInitialState 有什么区别？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>构造函数和getInitialState之间的区别就是ES6和ES5本身的区别。在使用ES6类时，应该在构造函数中初始化state，并在使用React.createClass时定义getInitialState方法。</p>
<pre><code class="language-javascript">class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { /* initial state */ };
  }
}
</code></pre>
<p>等价于：</p>
<pre><code class="language-javascript">var MyComponent = React.createClass({
  getInitialState() {
    return { /* initial state */ };
  },
});
</code></pre>
<h3 id="问题-30如何有条件地向-react-组件添加属性">问题 30：如何有条件地向 React 组件添加属性？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>对于某些属性，React 非常聪明，如果传递给它的值是虚值，可以省略该属性。例如：</p>
<pre><code class="language-javascript">var InputComponent = React.createClass({
    render: function() {
      var required = true;
      var disabled = false;

      return (
        &lt;input type=&quot;text&quot; disabled={disabled} required={required} /&gt;
      );
    }
});
</code></pre>
<p>渲染结果：</p>
<pre><code class="language-html">&lt;input type=&quot;text&quot; required&gt;
</code></pre>
<p>另一种可能的方法是：</p>
<pre><code class="language-javascript">var condition = true;

var component = (
  &lt;div
    value=&quot;foo&quot;
    { ...( condition &amp;&amp; { disabled: true } ) } /&gt;
);
</code></pre>
<h3 id="问题-31hooks会取代-render-props-和高阶组件吗">问题 31：Hooks会取代 render props 和高阶组件吗？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>通常，render props和高阶组件仅渲染一个子组件。React团队认为，Hooks 是服务此用例的更简单方法。</p>
<p>这两种模式仍然有一席之地(例如，一个虚拟的 scroller 组件可能有一个 renderItem prop，或者一个可视化的容器组件可能有它自己的 DOM 结构)。但在大多数情况下，Hooks 就足够了，可以帮助减少树中的嵌套。</p>
<h3 id="问题-32如何避免组件的重新渲染">问题 32：如何避免组件的重新渲染？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>React 中最常见的问题之一是组件不必要地重新渲染。React 提供了两个方法，在这些情况下非常有用：</p>
<ul>
<li>
<p>React.memo():这可以防止不必要地重新渲染函数组件</p>
</li>
<li>
<p>PureComponent:这可以防止不必要地重新渲染类组件</p>
</li>
</ul>
<p>这两种方法都依赖于对传递给组件的props的浅比较，如果 props 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。</p>
<p>通过使用 React Profiler，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。</p>
<h3 id="问题-33什么是纯函数">问题 33：什么是纯函数？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐⭐⭐</p>
</blockquote>
<p>纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。</p>
<h3 id="问题-34当调用setstate时react-render-是如何工作的">问题 34：当调用setState时，React render 是如何工作的？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐⭐⭐</p>
</blockquote>
<p>咱们可以将&quot;render&quot;分为两个步骤：</p>
<p>1.虚拟 DOM 渲染:当render方法被调用时，它返回一个新的组件的虚拟 DOM 结构。当调用setState()时，render会被再次调用，因为默认情况下shouldComponentUpdate总是返回true，所以默认情况下 React 是没有优化的。</p>
<p>2.原生 DOM 渲染:React 只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。</p>
<h3 id="问题-35如何避免在react重新绑定实例">问题 35：如何避免在React重新绑定实例？</h3>
<blockquote>
<p>主题: React<br>
难度: ⭐⭐⭐⭐⭐</p>
</blockquote>
<p>有几种常用方法可以避免在 React 中绑定方法：</p>
<p>1.将事件处理程序定义为内联箭头函数</p>
<pre><code class="language-javascript">class SubmitButton extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isFormSubmitted: false
    };
  }

  render() {
    return (
      &lt;button onClick={() =&gt; {
        this.setState({ isFormSubmitted: true });
      }}&gt;Submit&lt;/button&gt;
    )
  }
}
</code></pre>
<p>2.使用箭头函数来定义方法：</p>
<pre><code class="language-javascript">class SubmitButton extends React.Component {
  state = {
    isFormSubmitted: false
  }

  handleSubmit = () =&gt; {
    this.setState({
      isFormSubmitted: true
    });
  }

  render() {
    return (
      &lt;button onClick={this.handleSubmit}&gt;Submit&lt;/button&gt;
    )
  }
}
</code></pre>
<p>3.使用带有 Hooks 的函数组件</p>
<pre><code class="language-javascript">const SubmitButton = () =&gt; {
  const [isFormSubmitted, setIsFormSubmitted] = useState(false);

  return (
    &lt;button onClick={() =&gt; {
        setIsFormSubmitted(true);
    }}&gt;Submit&lt;/button&gt;
  )
};
</code></pre>
<p>作者：<a href="https://juejin.im/post/5dc20a4ff265da4d4e30040b">前端小智</a><br>
来源：掘金<br>
著作权归作者所有。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E9%97%AE%E9%A2%981%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9Fdom">问题1：什么是虚拟DOM？</a></li>
<li><a href="#%E9%97%AE%E9%A2%982%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E5%95%A5">问题2：类组件和函数组件之间的区别是啥？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-3react-%E4%B8%AD-refs-%E5%B9%B2%E5%98%9B%E7%94%A8%E7%9A%84">问题 3：React 中 refs 干嘛用的？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-4%E5%9C%A8-react-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BA%8B%E4%BB%B6">问题 4：在 React 中如何处理事件</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-5state-%E5%92%8C-props-%E5%8C%BA%E5%88%AB%E6%98%AF%E5%95%A5">问题 5：state 和 props 区别是啥？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-6%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA-refs">问题 6：如何创建 refs</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-7%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6">问题 7：什么是高阶组件？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-8%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8-super-%E5%B9%B6%E5%B0%86-props-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E5%85%A5%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E5%95%A5">问题 8：在构造函数调用 super 并将 props 作为参数传入的作用是啥？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-9%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A7%E5%88%B6%E7%BB%84%E4%BB%B6">问题 9：什么是控制组件？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-10%E5%A6%82%E4%BD%95-reactcreateelement">问题 10：如何 React.createElement ？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-11%E8%AE%B2%E8%AE%B2%E4%BB%80%E4%B9%88%E6%98%AF-jsx">问题 11：讲讲什么是 JSX ？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-12%E6%A0%B9%E6%8D%AE%E4%B8%8B%E9%9D%A2%E5%AE%9A%E4%B9%89%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%87%BA%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98%E5%90%97">问题 12：根据下面定义的代码，可以找出存在的两个问题吗 ？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-13%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E6%9B%B4%E6%96%B0-state-%E5%91%A2">问题 13：为什么不直接更新 state 呢 ?</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-14react-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5">问题 14：React 组件生命周期有哪些不同阶段？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-15react-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">问题 15：React 的生命周期方法有哪些？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-16%E8%BF%99%E4%B8%89%E4%B8%AA%E7%82%B9%E5%9C%A8-react-%E5%B9%B2%E5%98%9B%E7%94%A8%E7%9A%84">问题 16：这三个点(...)在 React 干嘛用的？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-17%E4%BD%BF%E7%94%A8-react-hooks-%E5%A5%BD%E5%A4%84%E6%98%AF%E5%95%A5">问题 17：使用 React Hooks 好处是啥？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-18%E4%BB%80%E4%B9%88%E6%98%AF-react-hooks">问题 18：什么是 React Hooks？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-19react-%E4%B8%AD%E7%9A%84-usestate-%E6%98%AF%E4%BB%80%E4%B9%88">问题 19：React 中的 useState() 是什么？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-20react-%E4%B8%AD%E7%9A%84strictmode%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">问题 20：React 中的StrictMode(严格模式)是什么？？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-21%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B1%BB%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E7%BB%91%E5%AE%9A%E5%88%B0%E7%B1%BB%E5%AE%9E%E4%BE%8B">问题 21：为什么类方法需要绑定到类实例？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-22%E4%BB%80%E4%B9%88%E6%98%AF-prop-drilling%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D">问题 22：什么是 prop drilling，如何避免？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-23%E6%8F%8F%E8%BF%B0-flux-%E4%B8%8E-mvc">问题 23：描述 Flux 与 MVC？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-24%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%8C%BA%E5%88%AB%E6%98%AF%E5%95%A5">问题 24：受控组件和非受控组件区别是啥？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-25%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%90%97">问题 25：这段代码有什么问题吗？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-26%E4%BB%80%E4%B9%88%E6%98%AF-react-context">问题 26：什么是 React Context?</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-27%E4%BB%80%E4%B9%88%E6%98%AF-react-fiber">问题 27：什么是 React Fiber?</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-28%E5%A6%82%E4%BD%95%E5%9C%A8-reactjs-%E7%9A%84-props%E4%B8%8A%E5%BA%94%E7%94%A8%E9%AA%8C%E8%AF%81">问题 28：如何在 ReactJS 的 Props上应用验证？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-29%E5%9C%A8-react-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C-getinitialstate-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">问题 29：在 React 中使用构造函数和 getInitialState 有什么区别？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-30%E5%A6%82%E4%BD%95%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E5%90%91-react-%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7">问题 30：如何有条件地向 React 组件添加属性？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-31hooks%E4%BC%9A%E5%8F%96%E4%BB%A3-render-props-%E5%92%8C%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%90%97">问题 31：Hooks会取代 render props 和高阶组件吗？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-32%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BB%84%E4%BB%B6%E7%9A%84%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93">问题 32：如何避免组件的重新渲染？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-33%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0">问题 33：什么是纯函数？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-34%E5%BD%93%E8%B0%83%E7%94%A8setstate%E6%97%B6react-render-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">问题 34：当调用setState时，React render 是如何工作的？</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-35%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9C%A8react%E9%87%8D%E6%96%B0%E7%BB%91%E5%AE%9A%E5%AE%9E%E4%BE%8B">问题 35：如何避免在React重新绑定实例？</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="http://lionney.coding.me//post/yi-bo-eslint-xiao-ji-qiao">
              <h3 class="post-title">
                一波ESLint小技巧
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="http://lionney.coding.me//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
